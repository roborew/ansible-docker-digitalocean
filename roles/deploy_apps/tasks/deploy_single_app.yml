---
- name: "Set app variables for {{ app.name }}"
  set_fact:
    app_name: "{{ app.name }}"
    app_repo: "{{ app.repo }}"
    app_branch: "{{ app.branch | default('main') }}"
    app_dir: "{{ apps_base_dir }}/{{ app.name }}"
    app_hostname: "{{ app.hostname | default(app.name + '.' + ansible_default_ipv4.address + '.nip.io') }}"
    app_port: "{{ app.port | default('3000') }}"

- name: "Display deployment info for {{ app_name }}"
  debug:
    msg: |
      Deploying {{ app_name }}:
      - Repository: {{ app_repo }}
      - Branch: {{ app_branch }}
      - Directory: {{ app_dir }}
      - Hostname: {{ app_hostname }}
      - Port: {{ app_port }}

- name: "Clone/update {{ app_name }} repository"
  git:
    repo: "{{ app_repo }}"
    dest: "{{ app_dir }}"
    version: "{{ app_branch }}"
    force: "{{ git_force_update }}"
    accept_hostkey: "{{ git_accept_hostkey }}"
  become: true
  become_user: "{{ apps_user }}"

- name: "Set ownership of {{ app_name }} directory"
  file:
    path: "{{ app_dir }}"
    owner: "{{ apps_user }}"
    group: "{{ apps_group }}"
    recurse: true
    state: directory

- name: "Check if docker-compose.yml exists for {{ app_name }}"
  stat:
    path: "{{ app_dir }}/docker-compose.yml"
  register: compose_file

- name: "Check if compose.yml exists for {{ app_name }}"
  stat:
    path: "{{ app_dir }}/compose.yml"
  register: compose_file_alt
  when: not compose_file.stat.exists

- name: "Fail if no compose file found for {{ app_name }}"
  fail:
    msg: "No docker-compose.yml or compose.yml found in {{ app_dir }}"
  when: not compose_file.stat.exists and not compose_file_alt.stat.exists

- name: "Stop existing containers for {{ app_name }}"
  command: "{{ compose_command }} down"
  args:
    chdir: "{{ app_dir }}"
  become: true
  become_user: "{{ apps_user }}"
  ignore_errors: true

- name: "Clean up old/dangling images for {{ app_name }}"
  command: "docker image prune -f"
  become: true
  become_user: "{{ apps_user }}"
  when: cleanup_docker_images | default(true)
  ignore_errors: true

- name: "Pull latest images for {{ app_name }}"
  command: "{{ compose_command }} pull"
  args:
    chdir: "{{ app_dir }}"
  become: true
  become_user: "{{ apps_user }}"
  ignore_errors: true

- name: "Check if app needs to be built from source"
  shell: "{{ compose_command }} config | grep -q 'build:'"
  args:
    chdir: "{{ app_dir }}"
  become: true
  become_user: "{{ apps_user }}"
  register: needs_build
  failed_when: false
  changed_when: false

- name: "Build {{ app_name }} with progress output"
  shell: |
    echo "ðŸ—ï¸  Building {{ app_name }}..."
    {{ compose_command }} build --progress=plain --no-cache 2>&1 | tee /tmp/{{ app_name }}_build.log
    echo "Build exit code: $?"
  args:
    chdir: "{{ app_dir }}"
  become: true
  become_user: "{{ apps_user }}"
  environment:
    CADDY_HOSTNAME: "{{ app_hostname }}"
    CADDY_PORT: "{{ app_port }}"
    PROXY_NETWORK: "{{ proxy_network_name }}"
  register: build_result
  when: needs_build.rc == 0
  failed_when: build_result.rc != 0

- name: "Display build output for {{ app_name }}"
  debug:
    msg: |
      ðŸ—ï¸  Build completed for {{ app_name }}:
      {{ build_result.stdout | default('No build output') }}
  when: needs_build.rc == 0 and build_result is defined

- name: "Start {{ app_name }} with docker compose"
  shell: |
    echo "ðŸš€ Starting {{ app_name }}..."
    {{ compose_command }} up -d 2>&1 | tee /tmp/{{ app_name }}_deploy.log
    echo "Deploy exit code: $?"
  args:
    chdir: "{{ app_dir }}"
  become: true
  become_user: "{{ apps_user }}"
  environment:
    CADDY_HOSTNAME: "{{ app_hostname }}"
    CADDY_PORT: "{{ app_port }}"
    PROXY_NETWORK: "{{ proxy_network_name }}"
  register: deploy_result
  failed_when: deploy_result.rc != 0

- name: "Display startup output for {{ app_name }}"
  debug:
    msg: |
      ðŸš€ Startup completed for {{ app_name }}:
      {{ deploy_result.stdout }}

- name: "Wait for {{ app_name }} containers to be ready"
  wait_for:
    timeout: 30
  delegate_to: localhost
  become: false

- name: "Verify {{ app_name }} containers are running"
  shell: "{{ compose_command }} ps --format json"
  args:
    chdir: "{{ app_dir }}"
  become: true
  become_user: "{{ apps_user }}"
  register: compose_status
  changed_when: false

- name: "Check container health for {{ app_name }}"
  shell: |
    echo "ðŸ“Š Container Status for {{ app_name }}:"
    {{ compose_command }} ps
    echo ""
    echo "ðŸ“‹ Container Logs (last 20 lines):"
    {{ compose_command }} logs --tail=20
  args:
    chdir: "{{ app_dir }}"
  become: true
  become_user: "{{ apps_user }}"
  register: health_check
  changed_when: false

- name: "Display {{ app_name }} health status"
  debug:
    msg: |
      ðŸ“Š Health Check for {{ app_name }}:
      {{ health_check.stdout }}

- name: "Save deployment logs for {{ app_name }}"
  shell: |
    mkdir -p /var/log/ansible-deployments
    cat > /var/log/ansible-deployments/{{ app_name }}_$(date +%Y%m%d_%H%M%S).log << EOF
    Deployment: {{ app_name }}
    Timestamp: $(date)
    Repository: {{ app_repo }}
    Branch: {{ app_branch }}

    Build Output:
    $(cat /tmp/{{ app_name }}_build.log 2>/dev/null || echo "No build required")

    Deploy Output:
    $(cat /tmp/{{ app_name }}_deploy.log)

    Final Status:
    $({{ compose_command }} ps)
    EOF
    echo "ðŸ“„ Deployment log saved to /var/log/ansible-deployments/"
  args:
    chdir: "{{ app_dir }}"
  become: true

- name: "Display {{ app_name }} final status"
  debug:
    msg: |
      ðŸŽ‰ {{ app_name }} deployment complete!
      - Directory: {{ app_dir }}
      - URL: https://{{ app_hostname }}
      - Status: Containers verified and running
      - Build logs: /tmp/{{ app_name }}_build.log
      - Deploy logs: /tmp/{{ app_name }}_deploy.log
      - Full deployment log: /var/log/ansible-deployments/{{ app_name }}_*.log
